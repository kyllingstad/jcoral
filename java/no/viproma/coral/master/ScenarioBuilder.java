/* Copyright 2014-2017, SINTEF Ocean.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package no.viproma.coral.master;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;

import no.viproma.coral.master.ScenarioEvent;
import no.viproma.coral.model.ScalarValue;


/**
 * A convenience class for "offline" scenario setup.
 * <p>
 * A companion to {@link ModelBuilder}, this class lets one create a simulation
 * scenario using slave and variable <em>names</em>, without having to know the
 * ID they'll get in a specific execution.  This allows one to easily
 * regenerate the same scenario for several executions.
 * <p>
 * The typical usage pattern is as follows:
 * <ol>
 *      <li>Create a model using {@code ModelBuilder}
 *      <li>Set up a scenario "blueprint" using {@code ScenarioBuilder}, taking
 *          care to use the exact same slave names as in step 1.  (Note that
 *          this class cannot verify the validity of the names at this step, as
 *          it does not know anything about the model.)
 *      <li>Spawn a new execution using {@link Execution}.
 *      <li>Set up the execution using {@link ModelBuilder#apply}, and keep the
 *          {@link ModelSlaveMap} it returns.
 *      <li>Create an execution-specific scenario by passing the
 *          {@code ModelSlaveMap} to {@link #build}.
 *      <li>Pass the generated scenario to {@link Execution#simulate}
 *          when running the simulation.
 *      <li>Repeat steps 3&ndash;6 with the same {@code ModelBuilder} and
 *          {@code ScenarioBuilder} if desirable.
 * </ol>
 */
public class ScenarioBuilder
{
    /** A class which represents an event in {@link ScenarioBuilder}. */
    public static class Event
    {
        /**
         * Constructs a variable value change event.
         * <p>
         * Note that the validity of {@code slaveName} and {@code variableName}
         * are not, and cannot be, verified by this function, as it does not have
         * information about the execution to which the scenario will apply.
         * Errors are reported at generation time, by {@code build()}.
         *
         * @param timePoint
         *      The point in simulated time at which this event will occur.
         * @param slaveName
         *      The name of a slave in the model.
         * @param variableName
         *      The name of one of the slave's variables.
         * @param newValue
         *      The new value of that variable.
         *
         * @throws IllegalArgumentException
         *      If {@code slaveName} or {@code variableName} are empty.
         */
        public Event(
            double timePoint,
            String slaveName,
            String variableName,
            ScalarValue newValue)
        {
            if (slaveName.isEmpty()) {
                throw new IllegalArgumentException("Slave name is empty");
            }
            if (variableName.isEmpty()) {
                throw new IllegalArgumentException("Variable name is empty");
            }
            timePoint_ = timePoint;
            slaveName_ = slaveName;
            variableName_ = variableName;
            newValue_ = newValue;
        }

        /** Returns the point in simulated time at which this event will occur. */
        public double getTimePoint() { return timePoint_; }

        /** Returns the name of the slave affected by this event. */
        public String getSlaveName() { return slaveName_; }

        /** Returns the name of the variable that gets changed at this event. */
        public String getVariableName() { return variableName_; }

        /** Returns the value to which the variable is changed at this event. */
        public ScalarValue getNewValue() { return newValue_; }

        private double timePoint_;
        private String slaveName_;
        private String variableName_;
        private ScalarValue newValue_;
    }

    /** Constructor. */
    public ScenarioBuilder()
    {
        events_ = new ArrayList<Event>();
    }

    /**
     * Adds an event to the scenario.
     * <p>
     * Events do not have to be added in order of increasing time.  They will
     * be sorted in the correct order when the scenario is generated by
     * {@link #build}.
     */
    public void addEvent(Event event)
    {
        events_.add(event);
    }

    /**
     * Adds a variable value change event to the scenario.
     * <p>
     * This is a convenience function which creates a new {@link Event} object,
     * forwarding all arguments to {@link Event#Event}, and adds the object
     * to the scenario using {@link #addEvent(Event)}.
     */
    public void addEvent(
        double timePoint,
        String slaveName,
        String variableName,
        ScalarValue newValue)
    {
        events_.add(new Event(timePoint, slaveName, variableName, newValue));
    }

    /**
     * Returns an iterable object which contains all events added to the
     * scenario so far.
     */
    public Iterable<Event> getEvents()
    {
        return events_;
    }

    /**
     * Generates an execution-specific scenario.
     *
     * @param modelSlaveMap
     *      Information about the slaves in the execution, as returned by
     *      {@link ModelBuilder#apply}.
     * @return
     *      A queue that contains all events previously added with
     *      {@link #addEvent}, in order of increasing time, with slave and
     *      variable names mapped to {@link no.viproma.coral.model.Variable}
     *      objects.
     * @throws EntityNotFoundException
     *      If a slave/variable previously specified with {@code addEvent()}
     *      was invalid.
     */
    public Queue<ScenarioEvent> build(ModelSlaveMap modelSlaveMap)
        throws EntityNotFoundException
    {
        Queue<ScenarioEvent> queue = new PriorityQueue<ScenarioEvent>(
            events_.size(),
            new Comparator<ScenarioEvent>() {
                public int compare(ScenarioEvent e1, ScenarioEvent e2)
                {
                    double t1 = e1.getTimePoint();
                    double t2 = e2.getTimePoint();
                    if (t1 < t2) return -1;
                    else if (t1 > t2) return 1;
                    else if (t1 == t2) return 0;
                    else throw new RuntimeException("Attempted to compare NaN values");
                }
            });

        for (Event e : events_) {
            queue.add(new ScenarioEvent(
                e.getTimePoint(),
                modelSlaveMap.getVariable(e.getSlaveName(), e.getVariableName()),
                e.getNewValue()));
        }
        return queue;
    }

    private List<Event> events_;
}

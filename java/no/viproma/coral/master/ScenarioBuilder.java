/* Copyright 2014-2017, SINTEF Ocean.
 * This Source Code Form is subject to the terms of the Mozilla Public
 * License, v. 2.0. If a copy of the MPL was not distributed with this
 * file, You can obtain one at http://mozilla.org/MPL/2.0/.
 */
package no.viproma.coral.master;

import java.util.ArrayList;
import java.util.Comparator;
import java.util.List;
import java.util.Map;
import java.util.PriorityQueue;
import java.util.Queue;

import no.viproma.coral.master.ScenarioEvent;
import no.viproma.coral.model.ScalarValue;


/**
 * A convenience class for "offline" scenario setup.
 * <p>
 * A companion to {@link ModelBuilder}, this class lets one create a simulation
 * scenario using slave and variable <em>names</em>, without having to know the
 * ID they'll get in a specific execution.  This allows one to easily
 * regenerate the same scenario for several executions.
 * <p>
 * The typical usage pattern is as follows:
 * <ol>
 *      <li>Create a model using {@code ModelBuilder}
 *      <li>Set up a scenario "blueprint" using {@code ScenarioBuilder}, taking
 *          care to use the exact same slave names as in step 1.  (Note that
 *          this class cannot verify the validity of the names at this step, as
 *          it does not know anything about the model.)
 *      <li>Spawn a new execution using {@link Execution}.
 *      <li>Set up the execution using {@link ModelBuilder#apply}, and keep the
 *          {@link ModelSlaveMap} it returns.
 *      <li>Create an execution-specific scenario by passing the
 *          {@code ModelSlaveMap} to {@link #build}.
 *      <li>Pass the generated scenario to {@link Execution#simulate}
 *          when running the simulation.
 *      <li>Repeat steps 3&ndash;6 with the same {@code ModelBuilder} and
 *          {@code ScenarioBuilder} if desirable.
 * </ol>
 */
public class ScenarioBuilder
{
    /** Constructor. */
    public ScenarioBuilder()
    {
        events_ = new ArrayList<Event>();
    }

    /**
     * Adds a variable value change event to the scenario.
     * <p>
     * Events do not have to be added in order of increasing time.  They will
     * be sorted in the correct order when the scenario is generated by
     * {@link #build}.
     * <p>
     * Note that the validity of {@code slaveName} and {@code variableName} are
     * not, and cannot be, verified by this function, as it does not have
     * information about the execution to which the scenario will apply.
     * Errors are reported at generation time, by {@code build()}.
     *
     * @param timePoint
     *      The point in simulated time at which this event will occur.
     * @param slaveName
     *      The name of a slave in the model.
     * @param variableName
     *      The name of one of the slave's variables.
     * @param value
     *      A value to set for that variable.
     */
    public void addEvent(
        double timePoint,
        String slaveName,
        String variableName,
        ScalarValue value)
    {
        events_.add(new Event(timePoint, slaveName, variableName, value));
    }

    /**
     * Generates an execution-specific scenario.
     *
     * @param modelSlaveMap
     *      Information about the slaves in the execution, as returned by
     *      {@link ModelBuilder#apply}.
     * @return
     *      A queue that contains all events previously added with
     *      {@link #addEvent}, in order of increasing time, with slave and
     *      variable names mapped to {@link no.viproma.coral.model.Variable}
     *      objects.
     * @throws EntityNotFoundException
     *      If a slave/variable previously specified with {@code addEvent()}
     *      was invalid.
     */
    public Queue<ScenarioEvent> build(ModelSlaveMap modelSlaveMap)
        throws EntityNotFoundException
    {
        Queue<ScenarioEvent> queue = new PriorityQueue<ScenarioEvent>(
            events_.size(),
            new Comparator<ScenarioEvent>() {
                public int compare(ScenarioEvent e1, ScenarioEvent e2)
                {
                    double t1 = e1.getTimePoint();
                    double t2 = e2.getTimePoint();
                    if (t1 < t2) return -1;
                    else if (t1 > t2) return 1;
                    else if (t1 == t2) return 0;
                    else throw new RuntimeException("Attempted to compare NaN values");
                }
            });

        for (Event e : events_) {
            queue.add(new ScenarioEvent(
                e.timePoint,
                modelSlaveMap.getVariable(e.slaveName, e.variableName),
                e.value));
        }
        return queue;
    }

    // =========================================================================

    private static class Event
    {
        public Event(double tp, String sn, String vn, ScalarValue vv)
        {
            timePoint = tp;
            slaveName = sn;
            variableName = vn;
            value = vv;
        }

        double timePoint;
        String slaveName;
        String variableName;
        ScalarValue value;
    }

    private List<Event> events_;
}
